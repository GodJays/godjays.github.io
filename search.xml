<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WMPageController与FDFullscreenPopGesture冲突</title>
      <link href="/wmpagecontroller-yu-fdfullscreenpopgesture-chong-tu/"/>
      <url>/wmpagecontroller-yu-fdfullscreenpopgesture-chong-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="WMPageController与FDFullscreenPopGesture冲突"><a href="#WMPageController与FDFullscreenPopGesture冲突" class="headerlink" title="WMPageController与FDFullscreenPopGesture冲突"></a>WMPageController与FDFullscreenPopGesture冲突</h2><h3 id="UINavgation侧滑失效，使用Method-swizzle解决"><a href="#UINavgation侧滑失效，使用Method-swizzle解决" class="headerlink" title="UINavgation侧滑失效，使用Method swizzle解决"></a>UINavgation侧滑失效，使用Method swizzle解决</h3><blockquote><p>通过swizzle 绑定 scrollView contentOffset.x 回调_FDFullscreenPopGestureRecognizerDelegate。WMScrollView的扩展类category， +load方法在程序启动之前完成方法交换。</p></blockquote><pre class="line-numbers language-objective-c"><code class="language-objective-c">#import "WMScrollView+PopGesture.h"#import <objc/runtime.h>static void swizzle(Class class, SEL original, SEL new) {    Method originalMethod = class_getInstanceMethod(class, original);    Method newMethod = class_getInstanceMethod(class, new);    if (class_addMethod(class, original, method_getImplementation(newMethod), method_getTypeEncoding(newMethod))) {        class_replaceMethod(class, new, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));    } else {        method_exchangeImplementations(originalMethod, newMethod);    }}@implementation WMScrollView (PopGesture)+(void)load {    swizzle(self, @selector(gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:), @selector(yx_gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:));}-(BOOL)yx_gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {    if (self.contentOffset.x <= 0) {        if ([otherGestureRecognizer.delegate isKindOfClass:NSClassFromString(@"_FDFullscreenPopGestureRecognizerDelegate")]) {            return true;        }    }    return false;    }@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令笔记</title>
      <link href="/hexo-chang-yong-ming-ling-bi-ji/"/>
      <url>/hexo-chang-yong-ming-ling-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo常用命令笔记"><a href="#hexo常用命令笔记" class="headerlink" title="hexo常用命令笔记"></a>hexo常用命令笔记</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><hr><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo -g <span class="token comment" spellcheck="true">#安装</span><span class="token function">npm</span> update hexo -g <span class="token comment" spellcheck="true">#升级</span><span class="token function">npm</span> init <span class="token comment" spellcheck="true">#初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><hr><pre class="line-numbers language-bash"><code class="language-bash">hexo n <span class="token string">"我的博客"</span> <span class="token operator">==</span> hexo new <span class="token string">"我的博客"</span> <span class="token comment" spellcheck="true">#新建文章</span>hexo p <span class="token operator">==</span> hexo publishhexo g <span class="token operator">==</span> hexo generate <span class="token comment" spellcheck="true">#生成</span>hexo s <span class="token operator">==</span> hexo server <span class="token comment" spellcheck="true">#启动服务预览</span>hexo d <span class="token operator">==</span> hexo deploy <span class="token comment" spellcheck="true">#部署</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><hr><pre class="line-numbers language-bash"><code class="language-bash">hexo server <span class="token comment" spellcheck="true">#Hexo 会监视文件变动并自动更新，您无需重启服务器。</span>hexo server -s <span class="token comment" spellcheck="true">#静态模式</span>hexo server -p 5000 <span class="token comment" spellcheck="true">#更改端口</span>hexo server -i 192.168.1.1 <span class="token comment" spellcheck="true">#自定义ip</span>hexo Clean <span class="token comment" spellcheck="true">#清除缓存</span>hexo g <span class="token comment" spellcheck="true">#生成静态网页</span>hexo d <span class="token comment" spellcheck="true">#开始部署</span>hexo s <span class="token comment" spellcheck="true">#启动服务器预览</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><hr><pre class="line-numbers language-bash"><code class="language-bash">hexo generate <span class="token comment" spellcheck="true">#使用Hexo 生成静态文件快速而简单</span>hexo generate --watch <span class="token comment" spellcheck="true">#监视文件变动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><hr><blockquote><p>两个命令的作用相同<br>hexo generate –deploy<br>hexo deploy –generate</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">hexo deploy -ghexo server -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><hr><pre class="line-numbers language-bash"><code class="language-bash">hexo new <span class="token string">"postName"</span> <span class="token comment" spellcheck="true">#新建文章</span>hexo new page <span class="token string">"pageName"</span> <span class="token comment" spellcheck="true">#新建页面</span>hexo generate <span class="token comment" spellcheck="true">#生成静态页面至public目录</span>hexo server <span class="token comment" spellcheck="true">#开启预览访问端口（默认端口4000， "ctrl + c"关闭server）</span>hexo deploy <span class="token comment" spellcheck="true">#将.deploy 目录部署到GitHub</span>hexo new  <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span>hexo new photo <span class="token string">"my Gallery"</span>hexo new <span class="token string">"Hellow World"</span> --lang en<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ios-CoreBluetooth</title>
      <link href="/ios-corebluetooth/"/>
      <url>/ios-corebluetooth/</url>
      
        <content type="html"><![CDATA[<h1>iOS蓝牙开发 CoreBluetooth </h1><h2 id="蓝牙中心设备的实现-蓝牙外设的实现"><a href="#蓝牙中心设备的实现-蓝牙外设的实现" class="headerlink" title="蓝牙中心设备的实现 蓝牙外设的实现"></a>蓝牙中心设备的实现 蓝牙外设的实现</h2><p>iOS蓝牙项目，在开发的过程中简单整理了一些与之相关的基础知识.</p><blockquote><p>1、iOS蓝牙开发的关键词<br>2、蓝牙的简单介绍.<br>3、CoreBluetooth框架.<br>4、实现iOS蓝牙外设 <a href="https://github.com/remember17/WHBLEDemo">(Demo)</a>.<br>5、实现iOS蓝牙中心设备 <a href="https://github.com/remember17/WHBLEDemo">(Demo)</a>.  </p></blockquote><p>Demo的运行gif图如下，中心设备可以从外设读取数据，也可以向外设写入数据。外设也可以向中心设备发送数据。<br>PS：需要使用真机测试。<br><img src="/./ios-CoreBluetooth/demoRun.gif" alt="蓝牙外设与中心设备之间的数据传输"></p><br>iOS的蓝牙开发是围绕着CoreBluetooth框架来实现的。下面先从iOS蓝牙开发的基本概念说起。<h3 id="一、iOS蓝牙开发的关键词"><a href="#一、iOS蓝牙开发的关键词" class="headerlink" title="一、iOS蓝牙开发的关键词"></a>一、iOS蓝牙开发的关键词</h3><blockquote><p>中心设备：就是用来扫描周围蓝牙硬件的设备，比如通过你手机的蓝牙来扫描并连接智能手环，这时候你的手机就是中心设备。</p><p>外设：被扫描的设备。比如当你用手机的蓝牙扫描连接智能手环的时候，智能手环就是外设。</p></blockquote><p><img src="/./ios-CoreBluetooth/centrlPeripheral.webp" alt="控制机和外设"></p><blockquote><p>广播：就是外设不停的散播蓝牙信号，让中心设备可以扫描到。</p></blockquote><p><img src="/./ios-CoreBluetooth/ad.webp" alt=" 广播"></p><blockquote><p>服务（services）：外设广播和运行的时候会有服务，可以理解成一个功能模块，中心设备可以读取服务。外设可以有多个服务。</p><p>特征（characteristic）：在服务中的一个单位，一个服务可以有多个特征，特征会有一个value，一般读写的数据就是这个value。<br><img src="/./ios-CoreBluetooth/%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%89%B9%E5%BE%81.webp" alt="服务和特征"></p></blockquote><blockquote><p>UUID：区分不同的服务和特征，可以理解为服务和特征的身份证。我们可以用UUID来挑选需要的服务和特征。</p></blockquote><h3 id="二、蓝牙的简单介绍"><a href="#二、蓝牙的简单介绍" class="headerlink" title="二、蓝牙的简单介绍"></a>二、蓝牙的简单介绍</h3><p>偷个懒：<a href="http://baike.baidu.com/link?url=26A1Z2mNOYQSnmndWMh2bCOA-PxMABVJD1Xae3jRhVVpo3kdCeeOWVqzYNeQbkkrjuUCdTFCpnf9kiuOYGZ3QAjjVIIO9SdDxbZzt9yl1Ny">蓝牙百科</a><br>蓝牙（ Bluetooth® ）：是一种短距离无线通信技术 ，可实现固定设备、移动设备和楼宇个人域网之间的短距离数据交换（使用2.4—2.485GHz的ISM波段的UHF无线电波）。蓝牙4.2发布于2014年12月2日。</p><h3 id="三、CoreBluetooth框架"><a href="#三、CoreBluetooth框架" class="headerlink" title="三、CoreBluetooth框架"></a>三、CoreBluetooth框架</h3><p><img src="/./ios-CoreBluetooth/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%B1%82%E6%AC%A1%E5%9B%BE.webp" alt="蓝牙开发层次图"></p><p>如上图所示，iOS中的蓝牙开发框架CoreBluetooth处在蓝牙低功耗协议栈的上面，我们开发的时候只是使用CoreBluetooth这个框架，通过CoreBluetooth可以轻松实现外设或中心设备的开发。</p><p>CoreBluetooth可以分为两大模块，中心设备central，外设peripheral，它们俩各有自己的一套API供我们使用。</p><p><img src="/./ios-CoreBluetooth/%E4%B8%AD%E5%BF%83%E8%AE%BE%E5%A4%87%E5%92%8C%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8.webp" alt="中心设备和外设使用"></p><p>上图左边的就是中心设备的开发类，我们平时是使用CBCentralManager来进行相关操作。</p><blockquote><p>CBCentralManager： 蓝牙中心设备管理类，用来统一调度中心设备的开发</p></blockquote><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">* CBPeripheral ：蓝牙外设，例如蓝牙手环、心率监测仪。* CBService ：蓝牙外设的服务，可以有0个或者多个服务。* CBCharacteristic ：服务中的特征，每一个蓝牙服务中可以有0个或多个特征，特征中包含数据信息。* CBUUID：可以理解为服务或特征的身份证，可以用来选择需要的服务和特征。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>右边是外设开发相关类，一般是围绕着CBPeripheralManager来进行编码。</p><blockquote><p>CBPeripheralManager： 蓝牙外设开发时使用，用来开发蓝牙外设的中心管理类。</p></blockquote><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">* CBCentral：蓝牙中心设备，例如用来连接蓝牙手环的手机。* CBMutableService：外设开发的时候可以添加多个服务，所有这里用CBMutableService来创建添加服务。* CBMutableCharacteristic：每个服务中可以有多个特征，外设开发给服务添加特征的时候使用这个类。* CBATTRequest：读或者写请求。它的实例对象有一个value属性，用来装载外设进行蓝牙读取或写入请求时的数据。一般在外设写入或读取的回调方法中有这一个参数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./ios-CoreBluetooth/%E5%A4%96%E8%AE%BE%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%89%B9%E5%BE%81.webp" alt="外设添加服务和特征"></p><h3 id="四、实现iOS蓝牙外设-Demo"><a href="#四、实现iOS蓝牙外设-Demo" class="headerlink" title="四、实现iOS蓝牙外设 (Demo)"></a>四、实现iOS蓝牙外设 <a href="https://github.com/remember17/WHBLEDemo">(Demo)</a></h3><p>  <img src="/./ios-CoreBluetooth/%E5%A4%96%E8%AE%BE%E7%AE%A1%E7%90%86%E5%99%A8.webp" alt="外设管理器"></p><h5>1、首先导入CoreBluetooth框架，并遵守协议</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">#import <CoreBluetooth/CoreBluetooth.h>// 遵守CBPeripheralManagerDelegate协议@interface ViewController () <CBPeripheralManagerDelegate><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5> 2、创建外设管理对象，用一个属性来强引用这个对象。并且在创建的时候设置代理，声明放到哪个线程。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">@property (nonatomic, strong) CBPeripheralManager *peripheralManager;// 创建外设管理器，会回调peripheralManagerDidUpdateState方法self.peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:dispatch_get_main_queue()];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5>  3、当创建CBPeripheralManager的时候，会回调判断蓝牙状态的方法。当蓝牙状态没问题的时候创建外设的Service（服务）和Characteristics（特征）。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/* 设备的蓝牙状态 CBManagerStateUnknown = 0,  未知 CBManagerStateResetting,    重置中 CBManagerStateUnsupported,  不支持 CBManagerStateUnauthorized, 未验证 CBManagerStatePoweredOff,   未启动 CBManagerStatePoweredOn,    可用 */- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral {    if (peripheral.state == CBManagerStatePoweredOn) {        // 创建Service（服务）和Characteristics（特征）        [self setupServiceAndCharacteristics];        // 根据服务的UUID开始广播        [self.peripheralManager startAdvertising:@{CBAdvertisementDataServiceUUIDsKey:@[[CBUUID UUIDWithString:SERVICE_UUID]]}];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以先用宏来做两个标识字符串，用来创建服务和特征的UUID。<br>最终把创建好的特征放进服务，把服务放入中心管理器。</p><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">#define SERVICE_UUID @"CDD1"#define CHARACTERISTIC_UUID @"CDD2"/** 创建服务和特征 */- (void)setupServiceAndCharacteristics {    // 创建服务    CBUUID *serviceID = [CBUUID UUIDWithString:SERVICE_UUID];    CBMutableService *service = [[CBMutableService alloc] initWithType:serviceID primary:YES];    // 创建服务中的特征    CBUUID *characteristicID = [CBUUID UUIDWithString:CHARACTERISTIC_UUID];    CBMutableCharacteristic *characteristic = [                                               [CBMutableCharacteristic alloc]                                               initWithType:characteristicID                                               properties:                                               CBCharacteristicPropertyRead |                                               CBCharacteristicPropertyWrite |                                               CBCharacteristicPropertyNotify                                               value:nil                                               permissions:CBAttributePermissionsReadable |                                               CBAttributePermissionsWriteable                                               ];    // 特征添加进服务    service.characteristics = @[characteristic];    // 服务加入管理    [self.peripheralManager addService:service];        // 为了手动给中心设备发送数据    self.characteristic = characteristic;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意CBCharacteristicPropertyNotify这个参数，只有设置了这个参数，在中心设备中才能订阅这个特征。<br>一般开发中可以设置两个特征，一个用来发送数据，一个用来接收中心设备写过来的数据，我们这里为了方便就只设置了一个特征。<br>最后用一个属性拿到这个特征，是为了后面单独发送数据的时候使用，数据的写入和读取最终还是要通过特征来完成。</p><h5>  4、当中心设备读取这个外设的数据的时候会回调这个方法。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 中心设备读取数据的时候回调 */- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request {    // 请求中的数据，这里把文本框中的数据发给中心设备    request.value = [self.textField.text dataUsingEncoding:NSUTF8StringEncoding];    // 成功响应请求    [peripheral respondToRequest:request withResult:CBATTErrorSuccess];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  5、当中心设备写入数据的时候，外设会调用下面这个方法。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 中心设备写入数据的时候回调 */- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray<CBATTRequest *> *)requests {    // 写入数据的请求    CBATTRequest *request = requests.lastObject;    // 把写入的数据显示在文本框中    self.textField.text = [[NSString alloc] initWithData:request.value encoding:NSUTF8StringEncoding];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  6、还有一个主动给中心设备发送数据的方法。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 通过固定的特征发送数据到中心设备 */- (IBAction)didClickPost:(id)sender {    BOOL sendSuccess = [self.peripheralManager updateValue:[self.textField.text dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:self.characteristic onSubscribedCentrals:nil];    if (sendSuccess) {        NSLog(@"数据发送成功");    }else {        NSLog(@"数据发送失败");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  7、中心设备订阅成功的时候回调。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 订阅成功回调 */-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic {    NSLog(@"%s",__FUNCTION__);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5>  8、中心设备取消订阅的时候回调。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 取消订阅回调 */-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic {    NSLog(@"%s",__FUNCTION__);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上就是iOS蓝牙外设的基本实现流程，当然还有更多的地方可以进一步处理，这就需要投入更多的时间来学习实验了。</p><hr><p>下面进入iOS蓝牙开发的主要部分，中心设备的实现，这也是手机App通常担任的角色。</p><h3 id="五、实现iOS蓝牙中心设备-Demo"><a href="#五、实现iOS蓝牙中心设备-Demo" class="headerlink" title="五、实现iOS蓝牙中心设备 (Demo)"></a>五、实现iOS蓝牙中心设备 <a href="https://github.com/remember17/WHBLEDemo">(Demo)</a></h3><p><img src="/./ios-CoreBluetooth/%E4%B8%AD%E5%BF%83%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8.webp" alt="中心设备管理器"></p><h5>  1、同外设开发一样，首先要导入CoreBluetooth框架。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">#import <CoreBluetooth/CoreBluetooth.h><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5>  2、遵守的协议与外设开发不同，中心设备的开发需要遵循如下两个协议。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">@interface ViewController () <CBCentralManagerDelegate,CBPeripheralDelegate><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5>  3、创建中心管理器并用属性强引用，创建的时候也会设置代理和选择线程。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">@property (nonatomic, strong) CBCentralManager *centralManager;// 创建中心设备管理器，会回调centralManagerDidUpdateStateself.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:dispatch_get_main_queue()];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5>  4、当创建中心管理对象的时候，会回调如下方法用来判断中心设备的蓝牙状态。当蓝牙状态没问题的时候，可以根据外设服务的UUID来扫描需要的外设。所以自然而然的就想到了要定义与外设UUID相同的宏。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 判断手机蓝牙状态 */#define SERVICE_UUID        @"CDD1"#define CHARACTERISTIC_UUID @"CDD2"- (void)centralManagerDidUpdateState:(CBCentralManager *)central {    // 蓝牙可用，开始扫描外设    if (central.state == CBManagerStatePoweredOn) {        NSLog(@"蓝牙可用");        // 根据SERVICE_UUID来扫描外设，如果不设置SERVICE_UUID，则扫描所有蓝牙设备        [central scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:SERVICE_UUID]] options:nil];    }    if(central.state==CBCentralManagerStateUnsupported) {        NSLog(@"该设备不支持蓝牙");    }    if (central.state==CBCentralManagerStatePoweredOff) {        NSLog(@"蓝牙已关闭");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  5、当扫描到外设之后，就会回调下面这个方法，可以在这个方法中继续设置筛选条件，例如根据外设名字的前缀来选择，如果符合条件就进行连接。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 发现符合要求的外设，回调 */- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary<NSString *, id> *)advertisementData RSSI:(NSNumber *)RSSI {    // 对外设对象进行强引用    self.peripheral = peripheral;//    if ([peripheral.name hasPrefix:@"WH"]) {//        // 可以根据外设名字来过滤外设//        [central connectPeripheral:peripheral options:nil];//    }    // 连接外设    [central connectPeripheral:peripheral options:nil];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  7、当连接成功的时候，就会来到下面这个方法。为了省电，当连接上外设之后，就让中心设备停止扫描，并且别忘记设置连接上的外设的代理。在这个方法里根据UUID进行服务的查找。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 连接成功 */- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral{    // 可以停止扫描    [self.centralManager stopScan];    // 设置代理    peripheral.delegate = self;    // 根据UUID来寻找服务    [peripheral discoverServices:@[[CBUUID UUIDWithString:SERVICE_UUID]]];    NSLog(@"连接成功");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  8、连接失败和断开连接也有各自的回调方法。在断开连接的时候，我们可以设置自动重连，根据项目需求来自定义里面的代码。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 连接失败的回调 */-(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error {    NSLog(@"连接失败");}/** 断开连接 */- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error {    NSLog(@"断开连接");    // 断开连接可以设置重新连接    [central connectPeripheral:peripheral options:nil];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  9、下面开始处理代理方法。</h5> &gt;最开始就是发现服务的方法。   &gt;这个方法里可以遍历服务，找到需要的服务。由于上面做的外设只有一个服务，所以我这里直接取服务中的最后一个lastObject就行了。找到服务之后，连贯的动作继续根据特征的UUID寻找服务中的特征。<pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 发现服务 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error {        // 遍历出外设中所有的服务    for (CBService *service in peripheral.services) {        NSLog(@"所有的服务：%@",service);    }        // 这里仅有一个服务，所以直接获取    CBService *service = peripheral.services.lastObject;    // 根据UUID寻找服务中的特征    [peripheral discoverCharacteristics:@[[CBUUID UUIDWithString:CHARACTERISTIC_UUID]] forService:service];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  10、下面这个方法里做的事情不少 </h5> &gt;当发现特征之后，与服务一样可以遍历特征，根据外设开发人员给的文档找出不同特征，做出相应的操作。  &gt;我的外设只设置了一个特征，所以也是直接通过lastObject拿到特征。再重复一遍，一般开发中可以设置两个特征，一个用来发送数据，一个用来接收中心设备写过来的数据。  &gt;这里用一个属性引用特征，是为了后面通过这个特征向外设写入数据或发送指令。  &gt;readValueForCharacteristic方法是直接读一次这个特征上的数据。<pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 发现特征回调 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error {        // 遍历出所需要的特征    for (CBCharacteristic *characteristic in service.characteristics) {        NSLog(@"所有特征：%@", characteristic);        // 从外设开发人员那里拿到不同特征的UUID，不同特征做不同事情，比如有读取数据的特征，也有写入数据的特征    }        // 这里只获取一个特征，写入数据的时候需要用到这个特征    self.characteristic = service.characteristics.lastObject;        // 直接读取这个特征数据，会调用didUpdateValueForCharacteristic    [peripheral readValueForCharacteristic:self.characteristic];        // 订阅通知    [peripheral setNotifyValue:YES forCharacteristic:self.characteristic];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>setNotifyValue:(BOOL)enabled forCharacteristic:(CBCharacteristic *)characteristic方法是对这个特征进行订阅，订阅成功之后，就可以监控外设中这个特征值得变化了。</p></blockquote><h5>  11、当订阅的状态发生改变的时候，下面的方法就派上用场了。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 订阅状态的改变 */-(void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {    if (error) {        NSLog(@"订阅失败");        NSLog(@"%@",error);    }    if (characteristic.isNotifying) {        NSLog(@"订阅成功");    } else {        NSLog(@"取消订阅");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  12、外设可以发送数据给中心设备，中心设备也可以从外设读取数据，当发生这些事情的时候，就会回调这个方法。通过特种中的value属性拿到原始数据，然后根据需求解析数据。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 接收到数据回调 */- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {    // 拿到外设发送过来的数据    NSData *data = characteristic.value;    self.textField.text = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5> 13、中心设备可以向外设写入数据，也可以向外设发送请求或指令，当需要进行这些操作的时候该怎么办呢。</h5> <ul><li>首先把要写入的数据转化为NSData格式，然后根据上面拿到的写入数据的特征，运用方法writeValue:(NSData *)data forCharacteristic:(CBCharacteristic *)characteristic type:(CBCharacteristicWriteType)type来进行数据的写入。</li><li>当写入数据的时候，系统也会回调这个方法peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(nonnull CBCharacteristic *)characteristic error:(nullable NSError *)error 。</li></ul><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 写入数据 */- (IBAction)didClickPost:(id)sender {    // 用NSData类型来写入    NSData *data = [self.textField.text dataUsingEncoding:NSUTF8StringEncoding];    // 根据上面的特征self.characteristic来写入数据    [self.peripheral writeValue:data forCharacteristic:self.characteristic type:CBCharacteristicWriteWithResponse];}/** 写入数据回调 */- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(nonnull CBCharacteristic *)characteristic error:(nullable NSError *)error {    NSLog(@"写入成功");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  14、中心设备如何主动从外设读取数据呢。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 读取数据 */- (IBAction)didClickGet:(id)sender {    [self.peripheral readValueForCharacteristic:self.characteristic];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>中心设备的开发是需要配合外设来进行的，一般会有硬件工程师或嵌入式工程师给出通信协议，根据协议来对项目的各种需求进行操作。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frontend </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
