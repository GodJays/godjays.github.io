<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iOS Method Swizzling 浅谈</title>
      <link href="/ios-method-swizzling-qian-tan/"/>
      <url>/ios-method-swizzling-qian-tan/</url>
      
        <content type="html"><![CDATA[<h3 id="iOS-Method-Swizzling-浅谈"><a href="#iOS-Method-Swizzling-浅谈" class="headerlink" title="iOS Method Swizzling 浅谈"></a>iOS Method Swizzling 浅谈</h3><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Method Swizzling的本质是在运行时交换方法实现（IMP），如hook系统方法，在原有的方法中，插入自己的业务需求。</p><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><ul><li>Objective-C的消息机制：在 Objective-C 中调用一个方法， 实际上是在底层通过 objc_msgSend()发送一个消息。 而查找消息的唯一依据是selector的方法名。</li></ul><pre class="line-numbers language-OBJC"><code class="language-OBJC">//调用方法  [obj doSomething];//[obj doSomething]本质上是给obj发doSomething消息objc_msgSend(obj,@selector(doSomething))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>每一个OC实例对象都保存有isa指针和实例变量，其中isa指针所属类，类维护一个运行时可接收的方法列表(MethodLists)；方法列表(MethodLists)中保存selector的方法名和方法实现(IMP，指向Method实现的指针)的映射关系。在运行时，通过selecter找到匹配的IMP，从而找到的具体的实现函数。</li></ul><p><img src="/./ios-method-swizzling-qian-tan/201701-f73fe838b5663cd2.webp" alt="MethodLists映射关系"></p><ul><li>开发中可以利用Objective-C的动态特性，在运行时替换selector对应的方法实现（IMP），达到给hook的目的。下图是利用 Method Swizzle 来替换selector对应IMP后的方法列表示意图。</li></ul><p><img src="/./ios-method-swizzling-qian-tan/201701-bdde607c08e1f34d.webp" alt="Method Swizzle方法列表"></p><h2 id="三、Method-Swizzling使用"><a href="#三、Method-Swizzling使用" class="headerlink" title="三、Method Swizzling使用"></a>三、Method Swizzling使用</h2><h1 id="load-initialize"><a href="#load-initialize" class="headerlink" title="+load  +initialize"></a>+load  +initialize</h1><p><strong>swizzling 应该只在 +load 中完成。</strong></p><p>在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。</p><h1 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h1><p><strong>swizzling 应该只在 dispatch_once 中完成。</strong></p><p>由于 swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once 满足了所需要的需求，并且应该被当做使用 swizzling 的初始化单例方法的标准。</p><h1 id="Selectors-Methods-amp-Implementations"><a href="#Selectors-Methods-amp-Implementations" class="headerlink" title="Selectors, Methods, &amp; Implementations"></a>Selectors, Methods, &amp; Implementations</h1><p>在 Objective-C 的运行时中，selectors, methods, implementations 指代了不同概念，然而我们通常会说在消息发送过程中，这三个概念是可以相互转换的。 下面是苹果 <em>Objective-C Runtime Reference</em>中的描述：</p><ul><li>Selector（typedef struct objc_selector *SEL）:在运行时 Selectors 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。Selector由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。</li><li>Method（typedef struct objc_method *Method）:方法是一个不透明的用来代表一个方法的定义的类型。</li><li>Implementation（typedef id (*IMP)(id, SEL,…)）:这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象 metaclass ）。第二个参数是这个方法的名字 selector，该方法的真正参数紧随其后。</li></ul><h1 id="理解-selector-method-implementation-这三个概念之间关系的最好方式是："><a href="#理解-selector-method-implementation-这三个概念之间关系的最好方式是：" class="headerlink" title="理解 selector, method, implementation 这三个概念之间关系的最好方式是："></a>理解 selector, method, implementation 这三个概念之间关系的最好方式是：</h1><ol><li>在运行时，类（Class）维护了一个消息分发列表来解决消息的正确发送。</li><li>每一个消息列表的入口是一个方法（Method），这个方法映射了一对键值对，</li><li>其中键值是这个方法的名字 selector（SEL），值是指向这个方法实现的函数指针 implementation（IMP）。 </li><li>Method swizzling 修改了类的消息分发列表使得已经存在的 selector 映射了另一个实现 implementation，同时重命名了原生方法的实现为一个新的 selector。</li></ol><h1 id="避坑-method-Swizzling会变得很可靠："><a href="#避坑-method-Swizzling会变得很可靠：" class="headerlink" title="避坑 method Swizzling会变得很可靠："></a>避坑 method Swizzling会变得很可靠：</h1><ul><li><b> 在交换方法实现后记得要调用原生方法的实现（除非你非常确定可以不用调用原生方法的实现）：APIs </b> 提供了输入输出的规则，而在输入输出中间的方法实现就是一个看不见的黑盒。交换了方法实现并且一些回调方法不会调用原生方法的实现这可能会造成底层实现的崩溃。</li><li><b>避免冲突</b> 为分类的方法加前缀，一定要确保调用了原生方法的所有地方不会因为你交换了方法的实现而出现意想不到的结果。</li><li><b>理解实现原理</b>:只是简单的拷贝粘贴交换方法实现的代码而不去理解实现原理不仅会让 App 很脆弱，并且浪费了学习 Objective-C 运行时的机会。阅读 Objective-C Runtime Reference 并且浏览 &lt;obje/runtime.h&gt; 能够让你更好理解实现原理。</li><li><b>持续的预防</b> ：不管你对你理解 swlzzling 框架，UIKit 或者其他内嵌框架有多自信，一定要记住所有东西在下一个发行版本都可能变得不再好使。做好准备，在使用这个黑魔法中走得更远，不要让程序反而出现不可思议的行为。</li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>Method Swizzling的本质就是偷换selector的IMP，下面就Swizzle NSObject的description方法，简单举例：</p><pre class="line-numbers language-OBJC"><code class="language-OBJC">#import "NSObject+Swizzle.h"#import <objc/runtime.h>@implementation NSObject (Swizzle)+ (void)load{   //调换IMP    Method originalMethod = class_getInstanceMethod([NSObject class], @selector(description));    Method myMethod = class_getInstanceMethod([NSObject class], @selector(qs_description));    method_exchangeImplementations(originalMethod, myMethod);}- (void)qs_description{    NSLog(@"description 被 Swizzle 了");    return [self qs_description];    }@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong> 调用被hook的description方法，获取内容前，会打印“description 被 Swizzle 了”这样的日志。</p><h2 id="四、Method-Swizzling存在的问题"><a href="#四、Method-Swizzling存在的问题" class="headerlink" title="四、Method Swizzling存在的问题"></a>四、Method Swizzling存在的问题</h2><ul><li>不是线程安全的(Method swizzling is not atomic)</li><li>改变了代码本来的行为(Changes behavior of un-owned code)</li><li>潜在的命名冲突（Possible naming conflicts）</li><li>改变方法的参数(Swizzling changes the method’s arguments)</li><li>继承问题(The order of swizzles matters)</li><li>难以理解 (Difficult to understand)</li><li>难以调试(Difficult to debug)</li></ul><h2 id="五、RSSwizzle：Method-Swizzling的优雅方案"><a href="#五、RSSwizzle：Method-Swizzling的优雅方案" class="headerlink" title="五、RSSwizzle：Method Swizzling的优雅方案"></a>五、RSSwizzle：Method Swizzling的优雅方案</h2><p>RSSwizzle是线程安全的Method Swizzling方案，能够帮我们解决Method Swizzling的使用问题。介绍如下：</p><p><strong>1、不是线程安全的(Method swizzling is not atomic)</strong></p><ul><li><p>通常在 load方法中交换方法实现，如果在其他时机交换方法实现，需要考虑线程安全的问题。</p></li><li><p>RSSwizzle利用了自旋锁OSSpinLock保证线程安全。可以在任意时机交换方法实现。</p></li></ul><p><strong>2、 改变了代码本来的行为(Changes behavior of un-owned code)</strong></p><ul><li><p>这正是Swizzle的目标。但是在Swizzle方法中，我们保留*调用原始实现的好习惯，能避免绝大多数问题。我们利用Swizzle，一般是为了在原始实现基础上，添加某些自己的业务需求，并不想刻意去破坏原有实现。</p></li><li><p>RSSwizzle提供调用原来实现的宏RSSWCallOriginal，很方便。</p></li></ul><p><strong>3、潜在的命名冲突（Possible naming conflicts）</strong></p><ul><li><p>通常在替换的方法名前加前缀，可以很大程度上避免命名冲突冲突问题。</p></li><li><p>RSSwizzle在自定义的swizzle的静态方法完成方法替换，完全避免了命名冲突问题。</p></li></ul><p><strong>4、改变方法的参数(Swizzling changes the method’s arguments)</strong></p><ul><li>参数 _cmd 被篡改，正常调用Swizzle 的方法有问题。</li></ul><pre class="line-numbers language-OBJC"><code class="language-OBJC">//调用方法 [self qs_setFrame:frame];  //发消息objc_msgSend(self, @selector(qs_setFrame:), frame);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong> 在运行时，寻找qs_setFrame:的方法实现, _cmd参数虽然是 qs_setFrame: ，但是实际上找到的方法实现是原始的 setFrame: 实现。</p><p><strong>5、继承问题(The order of swizzles matters)</strong></p><ul><li><p>多个有继承关系的类的对象Swizzle时，先从父对象开始。 这样才能保证子类方法拿到父类中的被Swizzle的实现。</p></li><li><p>在load中Swizzle不用担心这种问题，因为load类方法会默认从父类开始调用。</p></li></ul><p><strong>6、难以理解 (Difficult to understand)</strong></p><ul><li><p>主要表现在调用原始实现，看起来像递归，有点懵。</p></li><li><p>RSSwizzle提供的宏RSSWCallOriginal让调用原始实现更容易，代码阅读性更强。</p></li></ul><p><strong>7、难以调试(Difficult to debug)</strong></p><ul><li><p>Debug时候打印出的backtrace(回溯)，其中掺杂着被swizzle的方法名，看起来比较乱，所以命名清晰很重要；</p></li><li><p>RSSwizzle打印出来的命名很清晰，此外Swizzle了什么，最好有文档记录。</p></li></ul><h2 id="六、RSSwizzle的基础使用"><a href="#六、RSSwizzle的基础使用" class="headerlink" title="六、RSSwizzle的基础使用"></a>六、RSSwizzle的基础使用</h2><p>RSSwizzle中提供了两种使用方式，一种是通过调用<strong>类方法</strong>来实现函数的替换，另一种是使用RSSwizzle定义的<strong>宏</strong>来进行函数的替换。</p><p><strong>1、 使用类方法替换实例方法实现</strong></p><pre class="line-numbers language-OBJC"><code class="language-OBJC">/** 参数1：要被替换的函数选择器 参数2：要被替换的函数所在的类 参数3: block中返回替换后的方法,block参数中需要返回一个方法函数，这个函数为要替换成的函数，要和原函数类型相同。在类中的函数默认都会有一个名为self的id参数 参数4：此次替换用到的key */[RSSwizzle swizzleInstanceMethod:@selector(touchesBegan:withEvent:) inClass:[ViewController class] newImpFactory:^id(RSSwizzleInfo *swizzleInfo) {    return ^(__unsafe_unretained id self,NSSet* touches,UIEvent* event){        NSLog(@"touchesBegan:withEvent:被Swizzle了");    };} mode:RSSwizzleModeAlways key:NULL];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、 使用宏替换实例方法实现</strong></p><pre class="line-numbers language-OBJC"><code class="language-OBJC"> /* 参数1：要被替换的函数所在的类 参数2: 要被替换的函数选择器 参数3：返回值类型， 参数4：参数列表 参数5：要替换的代码块， 参数6：执行模式， 参数7：key值标识,RSSwizzleModeOncePerClass模式下使用，其他情况置为NULL */RSSwizzleInstanceMethod([ViewController class], @selector(touchesEnded:withEvent:), RSSWReturnType(void), RSSWArguments(NSSet<UITouch *> *touches,UIEvent *event),RSSWReplacement({        NSLog(@"touchesEnded:withEvent被Swizzle了");    RSSWCallOriginal(touches,event);}), RSSwizzleModeAlways, NULL);    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、 使用类方法替换类方法实现</strong></p><pre class="line-numbers language-OBJC"><code class="language-OBJC">/* 参数1：要替换的函数选择器 参数2：要替换此函数的类 参数3：block中返回替换后的方法,block参数中需要返回一个方法函数，这个函数为要替换成的函数，要和原函数类型相同。在类中的函数默认都会有一个名为self的id参数 */[RSSwizzle swizzleClassMethod:@selector(testClassMethod1) inClass:[ViewController class] newImpFactory:^id(RSSwizzleInfo *swizzleInfo) {        return ^(__unsafe_unretained id self){        NSLog(@"Class testClassMethod1 Swizzle");    };}];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、使用宏替换类方法实现</strong></p><pre class="line-numbers language-OBJC"><code class="language-OBJC">/* 参数1：要替换方法的类 参数2：要替换的方法选择器 参数3：方法的返回值类型 参数4：方法的参数列表 参数5：要替换的方法代码块 */RSSwizzleClassMethod(NSClassFromString(@"ViewController"), NSSelectorFromString(@"testClassMethod2"), RSSWReturnType(void), RSSWArguments(), RSSWReplacement({    //先执行原始方法    RSSWCallOriginal();    NSLog(@"Class testClassMethod2 Swizzle");}));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong> RSSwizzle还提供了Swizzle模式，使用Swizzle实例方法时候需要用到。Swizzle类方法，默认RSSwizzleModeAlways，定义如下：</p><pre class="line-numbers language-OBJC"><code class="language-OBJC">typedef NS_ENUM(NSUInteger, RSSwizzleMode) {    //任何情况下 始终执行替换操作    RSSwizzleModeAlways = 0,    //相同key标识的替换操作只会被执行一次    RSSwizzleModeOncePerClass = 1,    //相同key标识的替换操作在子类父类中只会被执行一次    RSSwizzleModeOncePerClassAndSuperclasses = 2};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、一个使用Swizzling典型的错误案例"><a href="#七、一个使用Swizzling典型的错误案例" class="headerlink" title="七、一个使用Swizzling典型的错误案例"></a>七、一个使用Swizzling典型的错误案例</h2><p>网络上很多博客介绍了使用Swizzling来<strong>防止重复点击UIButton</strong>，但是大部分都会有问题。</p><p><strong>1、错误代码</strong></p><p>一般在load中替换sendAction:to:forEvent:方法，主要代码如下：</p><pre class="line-numbers language-OBJC"><code class="language-OBJC">+ (void)load {    Method before   = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:));    Method after    = class_getInstanceMethod(self, @selector(qs_sendAction:to:forEvent:));    method_exchangeImplementations(before, after);}- (void)qs_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {    if ([NSDate date].timeIntervalSince1970 - self.qs_acceptEventTime < self.qs_acceptEventInterval) {        return;    }    if (self.qs_acceptEventInterval > 0) {        self.qs_acceptEventTime = [NSDate date].timeIntervalSince1970;    }     [self qs_sendAction:action to:target forEvent:event]; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>错误现象：</strong></p><ol><li><p><strong>UITabBarButton</strong>是UITabBarController中各个子控制器在工具条中对应的按钮，是UITabBar的私有属性，UITabBarButton的父类是UIControl，而UIButton的父类也是UIControl，sendAction:to:forEvent:是UIControl的实例方法；</p></li><li><p>在UIButton类中没有sendAction:to:forEvent:这个方法实现，通过class_getInstanceMethod() 获取的是父类的 Method 对象，使用 method_exchangeImplementations() 就把父类的原始实现（IMP）跟自己的 Swizzle 实现交换了。这就导致UIControl的其他子类，如UITabBarButton在被点击后，都调用了UIButton的Swizzle 实现，发生了严重的Crash问题。</p></li></ol><p><strong>说明：</strong> 虽然在UIControl的分类的load方法交换方法实现，能解决问题，我们将Swizzling的影响扩大很多倍，不是理想的做法。下面介绍解决办法。</p><p><strong>2、解决办法</strong></p><p>在项目直接使用method_exchangeImplementations很危险，甚至导致Crash，在项目中不建议这么做。可采用的解决办法有两种：</p><p><strong>方法A</strong></p><p>原理：如果类中没有实现 Original Selector 对应的方法，那就通过class_addMethod方法为Original Selector增加Swizzle 的实现，通过class_replaceMethod修改Swizzle Selector 的 实现 为 Original 的实现；如果已经有Original Selector 对应的方法（通过class_addMethod方法添加是失败的）, 这时才使用method_exchangeImplementations来直接交换。</p><pre class="line-numbers language-OBJC"><code class="language-OBJC">+ (void)load {    static dispatch_once_t onceToken;    dispatch_once(&onceToken, ^{        Class class = [self class];        SEL originalSelector = @selector(sendAction:to:forEvent:);        SEL swizzledSelector = @selector(qs_sendAction:to:forEvent:);         Method originalMethod = class_getInstanceMethod(class, originalSelector);        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);            BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));        if (success) {            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));        } else {            method_exchangeImplementations(originalMethod, swizzledMethod);        }    });}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明1：</strong> class_addMethod方法可以为类添加新的方法实现(IMP)，添加成功返回YES.。否则返回NO。如果选择器(select)已经有对应的方法实现（IMP）, 添加也是失败的，利用这点可以检查是否有源方法实现，如果没有利用class_replaceMethod来将swizzledSelector和originalMethod对应设置好。</p><p><strong>说明2：</strong> class_replaceMethod用来替换类中的方法实现，会调用class_addMethod和method_setImplementation方法（直接设置某个方法的IMP）</p><p><strong>方法B</strong><br>原理：RSSwizzle完美避开了在load中使用method_exchangeImplementations交换方法的尴尬，基于Swizzle模式和class_replaceMethod完美控制了替换方法实现。</p><pre class="line-numbers language-OBJC"><code class="language-OBJC">+ (void)load{    RSSwizzleInstanceMethod([UIButton class], @selector(sendAction:to:forEvent:), RSSWReturnType(void), RSSWArguments(SEL action,id target,UIEvent *event), RSSWReplacement({           UIButton *btn = self;            if ([NSDate date].timeIntervalSince1970 - btn.qs_acceptEventTime < btn.qs_acceptEventInterval) {                return;            }                  if (btn.qs_acceptEventInterval > 0) {                btn.qs_acceptEventTime = [NSDate date].timeIntervalSince1970;            }                    RSSWCallOriginal(action,target,event);        }), RSSwizzleModeAlways, NULL);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong> RSSwizzleInstanceMethod宏实现方法实现的替换，代码更易阅读。</p>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parallels Desktop 17 破解教程  MacBook M1 安装 Windows 11</title>
      <link href="/parallels-desktop-17-po-jie-jiao-cheng-macbook-m1-an-zhuang-windows-11/"/>
      <url>/parallels-desktop-17-po-jie-jiao-cheng-macbook-m1-an-zhuang-windows-11/</url>
      
        <content type="html"><![CDATA[<h2 id="Parallels-Desktop-17-破解教程-MacBook-M1-安装-Windows-11"><a href="#Parallels-Desktop-17-破解教程-MacBook-M1-安装-Windows-11" class="headerlink" title="Parallels Desktop 17 破解教程  MacBook M1 安装 Windows 11"></a>Parallels Desktop 17 破解教程  MacBook M1 安装 Windows 11</h2><blockquote><p>适用于Parallels Desktop的启动器, 可以无视试用期限强制启动客户机 (支持 PD17.1.0)</p></blockquote><p>PDrunner是一个菜单栏APP, 启动后会在菜单栏显示程序图标. 点击菜单栏图标可列出当前Mac上安装的所有客户机, 然后点击客户机名称即可启动对应的客户机.</p><p>PD Runner 是适用于 Parallels Desktop 17 的一款无限试用启动器。支持 Intel/ARM m1 使用，也支持 macOS 12，USB、网络一切都是正常的。此工具是开源免费的，感谢开发者 lihaoyun6 的付出。</p><h3 id="关于PD："><a href="#关于PD：" class="headerlink" title="关于PD："></a>关于PD：</h3><p>去 PD 官网下载 PD 17 试用版：<a href="https://www.parallels.cn/products/desktop/trial/">点我去下载</a>(支持 Parallels Desktop 17.1)</p><p>下载完成后安装，安装完成后运行 PD（要登录一下账号！！！如果没有账号，去注册一个 pd 的账号，然后登录，登录后点试用，会送你 14 天试用）。</p><p>然后安装 Windows 虚拟机或者 linux/Ubuntu 虚拟机（未安装虚拟机的一定要先安装虚拟机，安装过的可以跳过这一步）。</p><p>彻底退出运行的 PD (不会的直接重启电脑)，然后运行安装的 「PD Runner」，在菜单栏会出现一个类似播放器的图标，点击它，再点击需要启动的虚拟机即可。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><blockquote><p>如果试用已过期，去把系统时间改成 2021 年 9 月 1 号或者改成在你试用期内的日期，然后运行 PD，弹出试用窗口的时候点击「继续试用」，然后把 PD 退出，系统时间改回来，再用启动器启动即可。</p></blockquote><blockquote><p>为了方便使用你可以打开启动台，将 PD Runner 拖到你的 Dock 栏中（程序坞），启动器无视试用到期，也不用修改系统时间，就算到期了也一样可以用。</p></blockquote><h3 id="关于启动器："><a href="#关于启动器：" class="headerlink" title="关于启动器："></a>关于启动器：</h3><p> 此工具来自「lihaoyun6」的开源免费分享，如果您是在淘宝/咸鱼等地方购买的，请联系其退款并进行举报。</p><p>此工具非破解工具，只是使用了 PD 官方提供的方法启动。</p><p>关于 ARM M1 安装 Windows：</p><p>ARM M1 只能安装 Arm 架构的 windows 或者 linux 系统 ！！！</p><p>关于 Windows 用户：</p><p>请直接去微软官方下载镜像即可。</p><p>软件原理：因为针对PD 17.1.0新引入的鉴权措施, 需要通过快速切换系统时间来绕过. 软件进行修改时间的操作进行虚拟机的启动。</p><p>软件没有主窗口，只有状态栏菜单。</p><p>请低调使用，支持正版</p><hr><blockquote><p>另外附上一个拼多多的版本。</p></blockquote><p>mac版parallels17.1 兼容M1 可安装Win11</p><p>链接：<a href="https://pan.baidu.com/s/1yaLJCqxKFObmAJv-699RgQ">https://pan.baidu.com/s/1yaLJCqxKFObmAJv-699RgQ</a><br>提取码：1234</p><hr><p>注意：这个方法目前只对<code>PD17.0</code>版本有效，最新版本<code>PD17.1</code>仍然需要先更改系统时间（更改为2020年）之后才能打开。</p><p>为了一劳永逸，建议下载17.0的版本并且关闭自动更新。</p><ul><li>注：如果你的PD软件还在试用期，或者已经过了试用期（但还没有删除重装过PD软件），本工具可以直接启动虚拟机系统。</li></ul><h3 id="使用其它虚拟机怎么办？"><a href="#使用其它虚拟机怎么办？" class="headerlink" title="使用其它虚拟机怎么办？"></a>使用其它虚拟机怎么办？</h3><p>本引导工具，默认可以引导Win10虚拟机，如果需要引导其它虚拟机，可以右键Dock栏的PD，选择控制中心，点虚拟机旁的齿轮图标，选择通用，把其它虚拟机的名称改成Windows 11<code>（注意大小写和空格</code>）即可。</p><p><img src="/./parallels-desktop-17-po-jie-jiao-cheng-macbook-m1-an-zhuang-windows-11/image-3c2dfc2035f041a4b5f9c69c63063fc3.webp" alt="注意大小写和空格）"></p><h3 id="日后使用须知："><a href="#日后使用须知：" class="headerlink" title="日后使用须知："></a>日后使用须知：</h3><ul><li>虚拟机关机后，运行我们的小工具可以绕过激活，直接进入系统。如果运行小工具后，你的虚拟机是中止状态或者是休眠状态，不用关闭窗口，再运行一下小工具就可以唤醒了。</li><li>注意<code>不要到控制中心启动虚拟机</code>，肯定会出现试用期提示。如果虚拟机处于中止或者休眠状态，也不要在虚拟机窗口点击，肯定会弹出PD试用期弹窗。正确做法是：通过我们的小工具来启动或者唤醒。</li><li>PD官方的试用期结束后，我们的这个工具依然有效，可以脱离激活管控，一键启动虚拟机系统，永久使用，支持更新。</li><li>以后在使用过程中，<code>有一定的几率会弹出试用期已经过期的提示，但不会经常弹出，是正常现象，直接关闭那个弹窗</code>，不会影响虚拟机运行。</li><li>祝使用愉快！</li></ul><hr><h3 id="PD-Runner-破解思路"><a href="#PD-Runner-破解思路" class="headerlink" title="PD Runner 破解思路"></a>PD Runner 破解思路</h3><blockquote><p>其实这个破解思路就是使用了B站白嫖PD17？手把手教你制作PD17的启动器，不信你学不会！的制作启动器的方法，喜欢自己动手的朋友可以自己来尝试一下。</p></blockquote><pre><code>open -a /Applications/Parallels\ Desktop.app/usr/local/bin/prlctl start Windows 11 ARM64</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1 Mac装iOS应用还能这样玩：PlayCover</title>
      <link href="/m1-mac-zhuang-ios-ying-yong-huan-neng-zhe-yang-wan-playcover/"/>
      <url>/m1-mac-zhuang-ios-ying-yong-huan-neng-zhe-yang-wan-playcover/</url>
      
        <content type="html"><![CDATA[<h2 id="M1-Mac装iOS应用还能这样玩：PlayCover"><a href="#M1-Mac装iOS应用还能这样玩：PlayCover" class="headerlink" title="M1 Mac装iOS应用还能这样玩：PlayCover"></a>M1 Mac装iOS应用还能这样玩：PlayCover</h2><blockquote><p>让 macOS 直接运行 iOS 程序已经不是什么新鲜的事情了。自从 M1 系列的 Mac 问世以来，我们在 Mac App Store 甚至可以直接下载安装受支持的 iOS 应用，并用键盘鼠标来模拟触摸操作在 macOS 上使用这些 iOS 应用。虽然已经有很多 iOS 应用直接支持了在 macOS 上的安装，还是有一些应用开发者为了减少开发成本或者担心其他因素，选择将自己的 iOS 应用从 Mac App Store 上移除。</p></blockquote><blockquote><p>如果我们依旧希望<code>在系统架构完全支持的 M1 系列 Mac 上面</code>使用这些应用，那么就需要特殊的手段 —— 旁加载，也就是 sideloading —— 才能安装这些 iOS 应用。这是 macOS 11.2.3 之前的常规操作，我们称这段时期为「前 macOS 旁加载」时代。</p></blockquote><blockquote><p>显然，Apple 并不想让我们轻松地就将未经验证、不受支持的 iOS 应用直接在 macOS 上成功运行。曾被允许的简单「旁加载」在 macOS 11.3 的更新中被 Apple 禁用，自然最新的 macOS Monterey 12.1 也不受支持。因此，在「后 macOS 旁加载」时代，我们需要 PlayCover —— 一个专门用于在 M1 Mac 上安装 iOS 应用的辅助程序的帮助，才能够完整地在 M1 Mac 上面安装并体验未受支持的 iOS 应用。</p></blockquote><p><img src="/./m1-mac-zhuang-ios-ying-yong-huan-neng-zhe-yang-wan-playcover/8f9776b53bce431d460615dfb2f0970b.gif"></p><p>在 M1 Mac 上面运行由 PlayCover 安装的「原神」</p><h3 id="PlayCover-简介"><a href="#PlayCover-简介" class="headerlink" title="PlayCover 简介"></a>PlayCover 简介</h3><h3 id="后-macOS-旁加载时代-PlayCover-的优势"><a href="#后-macOS-旁加载时代-PlayCover-的优势" class="headerlink" title="后 macOS 旁加载时代 PlayCover 的优势"></a>后 macOS 旁加载时代 PlayCover 的优势</h3><blockquote><p>如前面提到，虽然依旧是「旁加载」的原理，但是 PlayCover 本身已经是一套完整的在 macOS 上运行 iOS 程序的辅助软件，相比于「前 macOS 旁加载」时代，PlayCover：</p></blockquote><ul><li>能够非常方便地在 M1 Mac 上面通过解密的 IPA 来安装 iOS 应用；</li><li>有着完整的键盘快捷键映射和鼠标操作映射，且支持快捷键映射导出导入；</li><li>也是我们在「后 macOS 旁加载」时期唯一的于 M1 Mac 上安装 iOS 应用的途径；</li></ul><blockquote><p>另外，PlayCover 的官方维护团队响应问题及时，社区资源丰富，开发者更新维护地也非常频繁，因此更是推荐大家安装使用。</p></blockquote><h3 id="安装-PlayCover"><a href="#安装-PlayCover" class="headerlink" title="安装 PlayCover"></a>安装 PlayCover</h3><blockquote><p>虽然 PlayCover 已经发布一段时间且也有自己的 官方网站，其依旧处于测试阶段，开发者的公告和发布渠道都集中于 PlayCover 官方 Discord 服务器。推荐大家优先加入官方 Discord 来获取最新的开发进度、更新日志以及疑难杂症的支持。</p></blockquote><blockquote><p>目前最新的 PlayCover 版本是 <code>0.9.63</code>，加入官方 Discord 之后可以看到开发者在 #announcements 频道 发布的更新信息，点击附件下载安装即可。</p></blockquote><p><img src="/./m1-mac-zhuang-ios-ying-yong-huan-neng-zhe-yang-wan-playcover/a9d90776c3a721a8d14007b6187d5b83.png"></p><p>PlayCover 的官方 Discord 服务器</p><blockquote><p>另外需要注意的是：由于 PlayCover 开发者并没有为自己的软件签名，因此首次打开 PlayCover 的时候需要进入 macOS 的「应用程序」文件夹，找到 PlayCover 之后「右键 - 打开」才能正常运行，从而不被 macOS 直接禁止运行并提示我们将软件移入废纸篓。</p></blockquote><h3 id="使用-PlayCover-安装-iOS-应用"><a href="#使用-PlayCover-安装-iOS-应用" class="headerlink" title="使用 PlayCover 安装 iOS 应用"></a>使用 PlayCover 安装 iOS 应用</h3><h3 id="获取已解密的-iOS-应用-IPA-安装包"><a href="#获取已解密的-iOS-应用-IPA-安装包" class="headerlink" title="获取已解密的 iOS 应用 IPA 安装包"></a>获取已解密的 iOS 应用 IPA 安装包</h3><blockquote><p>需要注意的是，PlayCover 是通过 IPA 文件来安装 iOS 应用的，且 PlayCover 仅支持安装由已越狱 iOS 设备上面导出的 IPA 文件，并不支持「前 macOS 旁加载」时代用比如 iMazing 导出的未解密 IPA 文件。这也就意味着，如果我们想要安装某个 iOS 应用，那么我们要么需要一台已越狱的 iOS 设备来导出相应的 IPA 文件，要么等待其他乐于助人的同学分享其导出的已解密 IPA 文件。</p></blockquote><blockquote><p>幸好，PlayCover 社区有着丰富的已解密 IPA 资源，由官方 Discord 服务器的成员上传分享。我们可以在 <code>#decrypted-ipas</code> 频道找到可供下载的 IPA 文件，使用 Discord 在本频道中搜索关键词寻找相应的 IPA，并点击分享链接将已经解密的 IPA 下载到 M1 Mac 中，准备安装。部分 IPA 也已经上传整理到 PlayCover IPA 分享站，我们也可以直接前往搜索下载。</p></blockquote><p><img src="/./m1-mac-zhuang-ios-ying-yong-huan-neng-zhe-yang-wan-playcover/07c2ecdcffa3e683ca3026717a106833.png"></p><p>PlayCover 官方 Discord 服务器中的已解密 IPA 分享频道</p><h3 id="使用-PlayCover-安装-IPA"><a href="#使用-PlayCover-安装-IPA" class="headerlink" title="使用 PlayCover 安装 IPA"></a>使用 PlayCover 安装 IPA</h3><blockquote><p>得到我们已解密的 IPA 安装文件之后，我们打开 PlayCover，选择 <code>Add app</code>，并在 Finder 中选择刚刚下载的 IPA 进行安装，PlayCover 就会对应用进行一系列的签名、修改等操作，绕过 Apple 的限制，将 iOS 应用在 M1 Mac 上成功安装，并安装如 PlayTools 的一系列辅助工具，让我们在 Mac 上面使用 iOS 应用更加方便。</p></blockquote><p><img src="/./m1-mac-zhuang-ios-ying-yong-huan-neng-zhe-yang-wan-playcover/709ff93aa955717d02b6514b3b172fbd.png"></p><p>PlayCover 应用主界面</p><blockquote><p>这样安装的应用在 PlayCover 主界面可以直接看到并单击运行，部分受支持的应用（比如原神）也可以点击绿色最大化按钮将窗口全屏显示，右键已安装的 iOS 应用还可以对其进行后续操作（比如启用 PlaySign、在 Finder 中打开安装的应用位置、清除应用缓存、导入导出键盘映射等等）。</p></blockquote><p><img src="/./m1-mac-zhuang-ios-ying-yong-huan-neng-zhe-yang-wan-playcover/bc9bbc1480d4cf3e9919f81e33841aa4.png"></p><p>通过 PlayCover 安装的应用，右键菜单对应用进行配置</p><blockquote><p>另外大家可能已经看到 PlayCover 已经在主界面提供了部分可供下载的 IPA 链接，但是这里提供的 IPA 并不全面，有些 IPA 链接给到的 iOS 软件版本已经落后，因此推荐大家优先在 Discord 服务器中寻找合适的 IPA 文件。</p></blockquote><h3 id="特殊-iOS-应用安装的必要操作"><a href="#特殊-iOS-应用安装的必要操作" class="headerlink" title="特殊 iOS 应用安装的必要操作"></a>特殊 iOS 应用安装的必要操作</h3><blockquote><p>部分 iOS 应用有特殊的安装步骤，很多需要注意的内容都在 Discord 服务器的 <code>#faq-read-first</code> 进行了详细的说明，因此如果遇到 PlayCover 无法安装应用或已经安装的应用无法打开的问题，建议去此频道寻找解决方案。</p></blockquote><blockquote><p>其中，很大一部分 PlayCover 用户都是为了在 macOS 上运行原神。在 PlayCover <code>0.9.63</code>，原神 2.4 版本的情况下，我们可以：</p></blockquote><ul><li><p>进入 Recovery 模式暂时关闭 macOS 的 SIP 保护：</p><ul><li>重启 Mac 并按住电源键进入 Recovery 模式，选择 Options；</li><li>进入 Recovery 之后点击菜单栏的 Utilities，打开终端 Terminal；</li><li>输入 <code>csrutil disable</code> 并确认，输入密码完成命令执行后重启 Mac；</li></ul></li><li><p>在关闭了 SIP 保护的 macOS 中，打开终端并执行 </p><pre><code>sudo nvram boot-args="amfi_get_out_of_my_way=1"</code></pre><p>，来允许 <code>nvram boot-args</code>，并再次重启 Mac；</p></li><li><p>打开 PlayCover 之后点击界面下方的 <code>Enable PlaySign</code> 按钮；</p></li><li><p>打开安装好的原神，这里我们就应该能够正常登录了，但此时需要立刻快捷键 <code>Command + Q</code> 关闭原神，并重新启用 macOS 的 SIP 保护：</p><ul><li>同样的进入 Recovery 模式并在终端 Terminal 中输入 <code>csrutil enable</code> 并确认；</li><li>再次输入密码等待命令执行完成后重启 Mac；</li></ul></li><li><p>此时我们再打开 PlayCover 启动原神，就可以正常进入游戏了。</p></li></ul><blockquote><p>由于每个版本的 PlayCover 和原神都有不同的特殊安装操作，因此还请具体版本具体分析，在 PlayCover 的官方 Discord 服务器中及时查看相应的安装解决方法。</p></blockquote><h3 id="方便地使用键鼠模拟触屏操作"><a href="#方便地使用键鼠模拟触屏操作" class="headerlink" title="方便地使用键鼠模拟触屏操作"></a>方便地使用键鼠模拟触屏操作</h3><blockquote><p>PlayCover 除了解决了在 M1 Mac 上安装 iOS 应用的一大难题外，还能够通过键鼠操作映射（keymapping）来模拟触屏的操作，让在 Mac 上面使用 iOS 应用更为顺畅（让在 Mac 上玩原神等游戏 iOS 版本的体验更加接近 PC 端的操作）。</p></blockquote><blockquote><p>我们在 PlayCover 安装的应用中，使用快捷键 <code>Ctrl + K</code> 可以进入键鼠映射界面，其中：</p></blockquote><ul><li><p><code>Ctrl + '+/-'</code>：增大/缩小按钮大小</p></li><li><pre><code>Ctrl + Delete (Backspace)</code></pre><p>：移除某个按键映射</p></li><li><p><code>Alt / Option</code>：显示或隐藏鼠标</p></li></ul><blockquote><p>另外 PlayCover 也支持使用 <code>Ctrl + U</code> 开启宏的录制，<code>Ctrl + I</code> 结束录制，<code>Ctrl + O</code> 播放录制的宏。</p></blockquote><blockquote><p>当然，如果我们想要自己进行复杂的快捷键绑定，也可以直接导入其他已经设计好的键盘映射。在 PlayCover 官方 Discord 的 <code>#keymap-showcase</code> 频道，我们可以找到其他同学分享的键鼠映射，直接下载导入相应的游戏，从而更加方便快捷的使用键盘鼠标来操作。</p></blockquote><blockquote><p>对原神来说，其相应的键鼠映射位于：GENSHIN IMPACT KEYMAPPING，加入 Discord 服务器的同学可以直接点击进入频道下载，并在 PlayCover 主界面中安装好的游戏图标上右键，导入设置好的键盘映射文件。</p></blockquote><p><img src="/./m1-mac-zhuang-ios-ying-yong-huan-neng-zhe-yang-wan-playcover/4fd15c78bbaf36b2ec47f03787be0edd.png"></p><p>来自 Discord 服务器同学提供的完善的「原神」键鼠操作映射</p><blockquote><p>另外，PlayCover 安装的原神也原生支持了手柄操作，原神官方支持 Xbox 和 PlayStation 系列手柄，通过蓝牙连接到 Mac 上面之后，原神可以直接转换为手柄操作，无需经过键盘映射操作，和在 PC 或 PlayStation 主机上的游玩体验一致。</p></blockquote><h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><blockquote><p>不得不说，很大程度上是「在 macOS 上打原神」的需求，促使了 PlayCover 的诞生，但是 PlayCover 事实上已经发展成为一整套完善的「M1 Mac 运行 iOS 应用」的基础设施。同时 PlayCover 自己亦是不断迭代更新，不仅在尝试去除一些比如「关闭 SIP 保护」等看起来非常可疑的操作需要，还在继续添加更多丰富的应用和功能支持。</p></blockquote><blockquote><p>虽然目前 PlayCover 仅支持 Apple silicon 版本也就是搭载 M1 系列芯片的 Mac，根据官网信息显示，开发团队也将在未来增加对于 Intel 芯片 Mac 的支持，届时你也能在 Intel 芯片 Mac 装上 iOS 应用和游戏。</p></blockquote><p><img src="/./m1-mac-zhuang-ios-ying-yong-huan-neng-zhe-yang-wan-playcover/b5dc6664438f38807a9e0dd54cf9abbb.png"></p><blockquote><p>有着完善开发和社区支持的 PlayCover 的确是如今在 M1 Mac 上安装运行 iOS 应用的不二之选 —— 不论是游戏还是常规应用。</p></blockquote><blockquote><p>最后，要知道如今 PlayCover 提供的一些顽固应用安装的 workaround，很大一部分都是针对特定应用的特定版本，本文提到的部分方法也是很可能在某个应用版本更新之后直接失效的，因此再次提醒各位准备使用 PlayCover 的同学加入官方 Discord 来获取更多、更及时的安装方法支持。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WMPageController与FDFullscreenPopGesture冲突</title>
      <link href="/wmpagecontroller-yu-fdfullscreenpopgesture-chong-tu/"/>
      <url>/wmpagecontroller-yu-fdfullscreenpopgesture-chong-tu/</url>
      
        <content type="html"><![CDATA[<h2 id="WMPageController与FDFullscreenPopGesture冲突"><a href="#WMPageController与FDFullscreenPopGesture冲突" class="headerlink" title="WMPageController与FDFullscreenPopGesture冲突"></a>WMPageController与FDFullscreenPopGesture冲突</h2><h3 id="UINavgation侧滑失效，使用Method-swizzle解决"><a href="#UINavgation侧滑失效，使用Method-swizzle解决" class="headerlink" title="UINavgation侧滑失效，使用Method swizzle解决"></a>UINavgation侧滑失效，使用Method swizzle解决</h3><blockquote><p>通过swizzle 绑定 scrollView contentOffset.x 回调_FDFullscreenPopGestureRecognizerDelegate。WMScrollView的扩展类category， +load方法在程序启动之前完成方法交换。</p></blockquote><pre class="line-numbers language-objective-c"><code class="language-objective-c">#import "WMScrollView+PopGesture.h"#import <objc/runtime.h>static void swizzle(Class class, SEL original, SEL new) {    Method originalMethod = class_getInstanceMethod(class, original);    Method newMethod = class_getInstanceMethod(class, new);    if (class_addMethod(class, original, method_getImplementation(newMethod), method_getTypeEncoding(newMethod))) {        class_replaceMethod(class, new, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));    } else {        method_exchangeImplementations(originalMethod, newMethod);    }}@implementation WMScrollView (PopGesture)+(void)load {    swizzle(self, @selector(gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:), @selector(yx_gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:));}-(BOOL)yx_gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {    if (self.contentOffset.x <= 0) {        if ([otherGestureRecognizer.delegate isKindOfClass:NSClassFromString(@"_FDFullscreenPopGestureRecognizerDelegate")]) {            return true;        }    }    return false;    }@end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frontend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令笔记</title>
      <link href="/hexo-chang-yong-ming-ling-bi-ji/"/>
      <url>/hexo-chang-yong-ming-ling-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo常用命令笔记"><a href="#hexo常用命令笔记" class="headerlink" title="hexo常用命令笔记"></a>hexo常用命令笔记</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><hr><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo -g <span class="token comment" spellcheck="true">#安装</span><span class="token function">npm</span> update hexo -g <span class="token comment" spellcheck="true">#升级</span><span class="token function">npm</span> init <span class="token comment" spellcheck="true">#初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><hr><pre class="line-numbers language-bash"><code class="language-bash">hexo n <span class="token string">"我的博客"</span> <span class="token operator">==</span> hexo new <span class="token string">"我的博客"</span> <span class="token comment" spellcheck="true">#新建文章</span>hexo p <span class="token operator">==</span> hexo publishhexo g <span class="token operator">==</span> hexo generate <span class="token comment" spellcheck="true">#生成</span>hexo s <span class="token operator">==</span> hexo server <span class="token comment" spellcheck="true">#启动服务预览</span>hexo d <span class="token operator">==</span> hexo deploy <span class="token comment" spellcheck="true">#部署</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><hr><pre class="line-numbers language-bash"><code class="language-bash">hexo server <span class="token comment" spellcheck="true">#Hexo 会监视文件变动并自动更新，您无需重启服务器。</span>hexo server -s <span class="token comment" spellcheck="true">#静态模式</span>hexo server -p 5000 <span class="token comment" spellcheck="true">#更改端口</span>hexo server -i 192.168.1.1 <span class="token comment" spellcheck="true">#自定义ip</span>hexo Clean <span class="token comment" spellcheck="true">#清除缓存</span>hexo g <span class="token comment" spellcheck="true">#生成静态网页</span>hexo d <span class="token comment" spellcheck="true">#开始部署</span>hexo s <span class="token comment" spellcheck="true">#启动服务器预览</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><hr><pre class="line-numbers language-bash"><code class="language-bash">hexo generate <span class="token comment" spellcheck="true">#使用Hexo 生成静态文件快速而简单</span>hexo generate --watch <span class="token comment" spellcheck="true">#监视文件变动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h3><hr><blockquote><p>两个命令的作用相同<br>hexo generate –deploy<br>hexo deploy –generate</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">hexo deploy -ghexo server -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><hr><pre class="line-numbers language-bash"><code class="language-bash">hexo new <span class="token string">"postName"</span> <span class="token comment" spellcheck="true">#新建文章</span>hexo new page <span class="token string">"pageName"</span> <span class="token comment" spellcheck="true">#新建页面</span>hexo generate <span class="token comment" spellcheck="true">#生成静态页面至public目录</span>hexo server <span class="token comment" spellcheck="true">#开启预览访问端口（默认端口4000， "ctrl + c"关闭server）</span>hexo deploy <span class="token comment" spellcheck="true">#将.deploy 目录部署到GitHub</span>hexo new  <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span>hexo new photo <span class="token string">"my Gallery"</span>hexo new <span class="token string">"Hellow World"</span> --lang en<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ios-CoreBluetooth</title>
      <link href="/ios-corebluetooth/"/>
      <url>/ios-corebluetooth/</url>
      
        <content type="html"><![CDATA[<h1>iOS蓝牙开发 CoreBluetooth </h1><h2 id="蓝牙中心设备的实现-蓝牙外设的实现"><a href="#蓝牙中心设备的实现-蓝牙外设的实现" class="headerlink" title="蓝牙中心设备的实现 蓝牙外设的实现"></a>蓝牙中心设备的实现 蓝牙外设的实现</h2><p>iOS蓝牙项目，在开发的过程中简单整理了一些与之相关的基础知识.</p><blockquote><p>1、iOS蓝牙开发的关键词<br>2、蓝牙的简单介绍.<br>3、CoreBluetooth框架.<br>4、实现iOS蓝牙外设 <a href="https://github.com/remember17/WHBLEDemo">(Demo)</a>.<br>5、实现iOS蓝牙中心设备 <a href="https://github.com/remember17/WHBLEDemo">(Demo)</a>.  </p></blockquote><p>Demo的运行gif图如下，中心设备可以从外设读取数据，也可以向外设写入数据。外设也可以向中心设备发送数据。<br>PS：需要使用真机测试。<br><img src="/./ios-CoreBluetooth/demoRun.gif" alt="蓝牙外设与中心设备之间的数据传输"></p><br>iOS的蓝牙开发是围绕着CoreBluetooth框架来实现的。下面先从iOS蓝牙开发的基本概念说起。<h3 id="一、iOS蓝牙开发的关键词"><a href="#一、iOS蓝牙开发的关键词" class="headerlink" title="一、iOS蓝牙开发的关键词"></a>一、iOS蓝牙开发的关键词</h3><blockquote><p>中心设备：就是用来扫描周围蓝牙硬件的设备，比如通过你手机的蓝牙来扫描并连接智能手环，这时候你的手机就是中心设备。</p><p>外设：被扫描的设备。比如当你用手机的蓝牙扫描连接智能手环的时候，智能手环就是外设。</p></blockquote><p><img src="/./ios-CoreBluetooth/centrlPeripheral.webp" alt="控制机和外设"></p><blockquote><p>广播：就是外设不停的散播蓝牙信号，让中心设备可以扫描到。</p></blockquote><p><img src="/./ios-CoreBluetooth/ad.webp" alt=" 广播"></p><blockquote><p>服务（services）：外设广播和运行的时候会有服务，可以理解成一个功能模块，中心设备可以读取服务。外设可以有多个服务。</p><p>特征（characteristic）：在服务中的一个单位，一个服务可以有多个特征，特征会有一个value，一般读写的数据就是这个value。<br><img src="/./ios-CoreBluetooth/%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%89%B9%E5%BE%81.webp" alt="服务和特征"></p></blockquote><blockquote><p>UUID：区分不同的服务和特征，可以理解为服务和特征的身份证。我们可以用UUID来挑选需要的服务和特征。</p></blockquote><h3 id="二、蓝牙的简单介绍"><a href="#二、蓝牙的简单介绍" class="headerlink" title="二、蓝牙的简单介绍"></a>二、蓝牙的简单介绍</h3><p>偷个懒：<a href="http://baike.baidu.com/link?url=26A1Z2mNOYQSnmndWMh2bCOA-PxMABVJD1Xae3jRhVVpo3kdCeeOWVqzYNeQbkkrjuUCdTFCpnf9kiuOYGZ3QAjjVIIO9SdDxbZzt9yl1Ny">蓝牙百科</a><br>蓝牙（ Bluetooth® ）：是一种短距离无线通信技术 ，可实现固定设备、移动设备和楼宇个人域网之间的短距离数据交换（使用2.4—2.485GHz的ISM波段的UHF无线电波）。蓝牙4.2发布于2014年12月2日。</p><h3 id="三、CoreBluetooth框架"><a href="#三、CoreBluetooth框架" class="headerlink" title="三、CoreBluetooth框架"></a>三、CoreBluetooth框架</h3><p><img src="/./ios-CoreBluetooth/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E5%B1%82%E6%AC%A1%E5%9B%BE.webp" alt="蓝牙开发层次图"></p><p>如上图所示，iOS中的蓝牙开发框架CoreBluetooth处在蓝牙低功耗协议栈的上面，我们开发的时候只是使用CoreBluetooth这个框架，通过CoreBluetooth可以轻松实现外设或中心设备的开发。</p><p>CoreBluetooth可以分为两大模块，中心设备central，外设peripheral，它们俩各有自己的一套API供我们使用。</p><p><img src="/./ios-CoreBluetooth/%E4%B8%AD%E5%BF%83%E8%AE%BE%E5%A4%87%E5%92%8C%E5%A4%96%E8%AE%BE%E4%BD%BF%E7%94%A8.webp" alt="中心设备和外设使用"></p><p>上图左边的就是中心设备的开发类，我们平时是使用CBCentralManager来进行相关操作。</p><blockquote><p>CBCentralManager： 蓝牙中心设备管理类，用来统一调度中心设备的开发</p></blockquote><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">* CBPeripheral ：蓝牙外设，例如蓝牙手环、心率监测仪。* CBService ：蓝牙外设的服务，可以有0个或者多个服务。* CBCharacteristic ：服务中的特征，每一个蓝牙服务中可以有0个或多个特征，特征中包含数据信息。* CBUUID：可以理解为服务或特征的身份证，可以用来选择需要的服务和特征。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>右边是外设开发相关类，一般是围绕着CBPeripheralManager来进行编码。</p><blockquote><p>CBPeripheralManager： 蓝牙外设开发时使用，用来开发蓝牙外设的中心管理类。</p></blockquote><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">* CBCentral：蓝牙中心设备，例如用来连接蓝牙手环的手机。* CBMutableService：外设开发的时候可以添加多个服务，所有这里用CBMutableService来创建添加服务。* CBMutableCharacteristic：每个服务中可以有多个特征，外设开发给服务添加特征的时候使用这个类。* CBATTRequest：读或者写请求。它的实例对象有一个value属性，用来装载外设进行蓝牙读取或写入请求时的数据。一般在外设写入或读取的回调方法中有这一个参数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./ios-CoreBluetooth/%E5%A4%96%E8%AE%BE%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%89%B9%E5%BE%81.webp" alt="外设添加服务和特征"></p><h3 id="四、实现iOS蓝牙外设-Demo"><a href="#四、实现iOS蓝牙外设-Demo" class="headerlink" title="四、实现iOS蓝牙外设 (Demo)"></a>四、实现iOS蓝牙外设 <a href="https://github.com/remember17/WHBLEDemo">(Demo)</a></h3><p>  <img src="/./ios-CoreBluetooth/%E5%A4%96%E8%AE%BE%E7%AE%A1%E7%90%86%E5%99%A8.webp" alt="外设管理器"></p><h5>1、首先导入CoreBluetooth框架，并遵守协议</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">#import <CoreBluetooth/CoreBluetooth.h>// 遵守CBPeripheralManagerDelegate协议@interface ViewController () <CBPeripheralManagerDelegate><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5> 2、创建外设管理对象，用一个属性来强引用这个对象。并且在创建的时候设置代理，声明放到哪个线程。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">@property (nonatomic, strong) CBPeripheralManager *peripheralManager;// 创建外设管理器，会回调peripheralManagerDidUpdateState方法self.peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:dispatch_get_main_queue()];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5>  3、当创建CBPeripheralManager的时候，会回调判断蓝牙状态的方法。当蓝牙状态没问题的时候创建外设的Service（服务）和Characteristics（特征）。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/* 设备的蓝牙状态 CBManagerStateUnknown = 0,  未知 CBManagerStateResetting,    重置中 CBManagerStateUnsupported,  不支持 CBManagerStateUnauthorized, 未验证 CBManagerStatePoweredOff,   未启动 CBManagerStatePoweredOn,    可用 */- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral {    if (peripheral.state == CBManagerStatePoweredOn) {        // 创建Service（服务）和Characteristics（特征）        [self setupServiceAndCharacteristics];        // 根据服务的UUID开始广播        [self.peripheralManager startAdvertising:@{CBAdvertisementDataServiceUUIDsKey:@[[CBUUID UUIDWithString:SERVICE_UUID]]}];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以先用宏来做两个标识字符串，用来创建服务和特征的UUID。<br>最终把创建好的特征放进服务，把服务放入中心管理器。</p><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">#define SERVICE_UUID @"CDD1"#define CHARACTERISTIC_UUID @"CDD2"/** 创建服务和特征 */- (void)setupServiceAndCharacteristics {    // 创建服务    CBUUID *serviceID = [CBUUID UUIDWithString:SERVICE_UUID];    CBMutableService *service = [[CBMutableService alloc] initWithType:serviceID primary:YES];    // 创建服务中的特征    CBUUID *characteristicID = [CBUUID UUIDWithString:CHARACTERISTIC_UUID];    CBMutableCharacteristic *characteristic = [                                               [CBMutableCharacteristic alloc]                                               initWithType:characteristicID                                               properties:                                               CBCharacteristicPropertyRead |                                               CBCharacteristicPropertyWrite |                                               CBCharacteristicPropertyNotify                                               value:nil                                               permissions:CBAttributePermissionsReadable |                                               CBAttributePermissionsWriteable                                               ];    // 特征添加进服务    service.characteristics = @[characteristic];    // 服务加入管理    [self.peripheralManager addService:service];        // 为了手动给中心设备发送数据    self.characteristic = characteristic;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意CBCharacteristicPropertyNotify这个参数，只有设置了这个参数，在中心设备中才能订阅这个特征。<br>一般开发中可以设置两个特征，一个用来发送数据，一个用来接收中心设备写过来的数据，我们这里为了方便就只设置了一个特征。<br>最后用一个属性拿到这个特征，是为了后面单独发送数据的时候使用，数据的写入和读取最终还是要通过特征来完成。</p><h5>  4、当中心设备读取这个外设的数据的时候会回调这个方法。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 中心设备读取数据的时候回调 */- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request {    // 请求中的数据，这里把文本框中的数据发给中心设备    request.value = [self.textField.text dataUsingEncoding:NSUTF8StringEncoding];    // 成功响应请求    [peripheral respondToRequest:request withResult:CBATTErrorSuccess];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  5、当中心设备写入数据的时候，外设会调用下面这个方法。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 中心设备写入数据的时候回调 */- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray<CBATTRequest *> *)requests {    // 写入数据的请求    CBATTRequest *request = requests.lastObject;    // 把写入的数据显示在文本框中    self.textField.text = [[NSString alloc] initWithData:request.value encoding:NSUTF8StringEncoding];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  6、还有一个主动给中心设备发送数据的方法。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 通过固定的特征发送数据到中心设备 */- (IBAction)didClickPost:(id)sender {    BOOL sendSuccess = [self.peripheralManager updateValue:[self.textField.text dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:self.characteristic onSubscribedCentrals:nil];    if (sendSuccess) {        NSLog(@"数据发送成功");    }else {        NSLog(@"数据发送失败");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  7、中心设备订阅成功的时候回调。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 订阅成功回调 */-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic {    NSLog(@"%s",__FUNCTION__);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5>  8、中心设备取消订阅的时候回调。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 取消订阅回调 */-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic {    NSLog(@"%s",__FUNCTION__);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上就是iOS蓝牙外设的基本实现流程，当然还有更多的地方可以进一步处理，这就需要投入更多的时间来学习实验了。</p><hr><p>下面进入iOS蓝牙开发的主要部分，中心设备的实现，这也是手机App通常担任的角色。</p><h3 id="五、实现iOS蓝牙中心设备-Demo"><a href="#五、实现iOS蓝牙中心设备-Demo" class="headerlink" title="五、实现iOS蓝牙中心设备 (Demo)"></a>五、实现iOS蓝牙中心设备 <a href="https://github.com/remember17/WHBLEDemo">(Demo)</a></h3><p><img src="/./ios-CoreBluetooth/%E4%B8%AD%E5%BF%83%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8.webp" alt="中心设备管理器"></p><h5>  1、同外设开发一样，首先要导入CoreBluetooth框架。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">#import <CoreBluetooth/CoreBluetooth.h><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5>  2、遵守的协议与外设开发不同，中心设备的开发需要遵循如下两个协议。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">@interface ViewController () <CBCentralManagerDelegate,CBPeripheralDelegate><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5>  3、创建中心管理器并用属性强引用，创建的时候也会设置代理和选择线程。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">@property (nonatomic, strong) CBCentralManager *centralManager;// 创建中心设备管理器，会回调centralManagerDidUpdateStateself.centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:dispatch_get_main_queue()];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5>  4、当创建中心管理对象的时候，会回调如下方法用来判断中心设备的蓝牙状态。当蓝牙状态没问题的时候，可以根据外设服务的UUID来扫描需要的外设。所以自然而然的就想到了要定义与外设UUID相同的宏。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 判断手机蓝牙状态 */#define SERVICE_UUID        @"CDD1"#define CHARACTERISTIC_UUID @"CDD2"- (void)centralManagerDidUpdateState:(CBCentralManager *)central {    // 蓝牙可用，开始扫描外设    if (central.state == CBManagerStatePoweredOn) {        NSLog(@"蓝牙可用");        // 根据SERVICE_UUID来扫描外设，如果不设置SERVICE_UUID，则扫描所有蓝牙设备        [central scanForPeripheralsWithServices:@[[CBUUID UUIDWithString:SERVICE_UUID]] options:nil];    }    if(central.state==CBCentralManagerStateUnsupported) {        NSLog(@"该设备不支持蓝牙");    }    if (central.state==CBCentralManagerStatePoweredOff) {        NSLog(@"蓝牙已关闭");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  5、当扫描到外设之后，就会回调下面这个方法，可以在这个方法中继续设置筛选条件，例如根据外设名字的前缀来选择，如果符合条件就进行连接。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 发现符合要求的外设，回调 */- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary<NSString *, id> *)advertisementData RSSI:(NSNumber *)RSSI {    // 对外设对象进行强引用    self.peripheral = peripheral;//    if ([peripheral.name hasPrefix:@"WH"]) {//        // 可以根据外设名字来过滤外设//        [central connectPeripheral:peripheral options:nil];//    }    // 连接外设    [central connectPeripheral:peripheral options:nil];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  7、当连接成功的时候，就会来到下面这个方法。为了省电，当连接上外设之后，就让中心设备停止扫描，并且别忘记设置连接上的外设的代理。在这个方法里根据UUID进行服务的查找。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 连接成功 */- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral{    // 可以停止扫描    [self.centralManager stopScan];    // 设置代理    peripheral.delegate = self;    // 根据UUID来寻找服务    [peripheral discoverServices:@[[CBUUID UUIDWithString:SERVICE_UUID]]];    NSLog(@"连接成功");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  8、连接失败和断开连接也有各自的回调方法。在断开连接的时候，我们可以设置自动重连，根据项目需求来自定义里面的代码。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 连接失败的回调 */-(void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error {    NSLog(@"连接失败");}/** 断开连接 */- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(nullable NSError *)error {    NSLog(@"断开连接");    // 断开连接可以设置重新连接    [central connectPeripheral:peripheral options:nil];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  9、下面开始处理代理方法。</h5> &gt;最开始就是发现服务的方法。   &gt;这个方法里可以遍历服务，找到需要的服务。由于上面做的外设只有一个服务，所以我这里直接取服务中的最后一个lastObject就行了。找到服务之后，连贯的动作继续根据特征的UUID寻找服务中的特征。<pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 发现服务 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error {        // 遍历出外设中所有的服务    for (CBService *service in peripheral.services) {        NSLog(@"所有的服务：%@",service);    }        // 这里仅有一个服务，所以直接获取    CBService *service = peripheral.services.lastObject;    // 根据UUID寻找服务中的特征    [peripheral discoverCharacteristics:@[[CBUUID UUIDWithString:CHARACTERISTIC_UUID]] forService:service];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  10、下面这个方法里做的事情不少 </h5> &gt;当发现特征之后，与服务一样可以遍历特征，根据外设开发人员给的文档找出不同特征，做出相应的操作。  &gt;我的外设只设置了一个特征，所以也是直接通过lastObject拿到特征。再重复一遍，一般开发中可以设置两个特征，一个用来发送数据，一个用来接收中心设备写过来的数据。  &gt;这里用一个属性引用特征，是为了后面通过这个特征向外设写入数据或发送指令。  &gt;readValueForCharacteristic方法是直接读一次这个特征上的数据。<pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 发现特征回调 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error {        // 遍历出所需要的特征    for (CBCharacteristic *characteristic in service.characteristics) {        NSLog(@"所有特征：%@", characteristic);        // 从外设开发人员那里拿到不同特征的UUID，不同特征做不同事情，比如有读取数据的特征，也有写入数据的特征    }        // 这里只获取一个特征，写入数据的时候需要用到这个特征    self.characteristic = service.characteristics.lastObject;        // 直接读取这个特征数据，会调用didUpdateValueForCharacteristic    [peripheral readValueForCharacteristic:self.characteristic];        // 订阅通知    [peripheral setNotifyValue:YES forCharacteristic:self.characteristic];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>setNotifyValue:(BOOL)enabled forCharacteristic:(CBCharacteristic *)characteristic方法是对这个特征进行订阅，订阅成功之后，就可以监控外设中这个特征值得变化了。</p></blockquote><h5>  11、当订阅的状态发生改变的时候，下面的方法就派上用场了。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 订阅状态的改变 */-(void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {    if (error) {        NSLog(@"订阅失败");        NSLog(@"%@",error);    }    if (characteristic.isNotifying) {        NSLog(@"订阅成功");    } else {        NSLog(@"取消订阅");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  12、外设可以发送数据给中心设备，中心设备也可以从外设读取数据，当发生这些事情的时候，就会回调这个方法。通过特种中的value属性拿到原始数据，然后根据需求解析数据。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 接收到数据回调 */- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {    // 拿到外设发送过来的数据    NSData *data = characteristic.value;    self.textField.text = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5> 13、中心设备可以向外设写入数据，也可以向外设发送请求或指令，当需要进行这些操作的时候该怎么办呢。</h5> <ul><li>首先把要写入的数据转化为NSData格式，然后根据上面拿到的写入数据的特征，运用方法writeValue:(NSData *)data forCharacteristic:(CBCharacteristic *)characteristic type:(CBCharacteristicWriteType)type来进行数据的写入。</li><li>当写入数据的时候，系统也会回调这个方法peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(nonnull CBCharacteristic *)characteristic error:(nullable NSError *)error 。</li></ul><pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 写入数据 */- (IBAction)didClickPost:(id)sender {    // 用NSData类型来写入    NSData *data = [self.textField.text dataUsingEncoding:NSUTF8StringEncoding];    // 根据上面的特征self.characteristic来写入数据    [self.peripheral writeValue:data forCharacteristic:self.characteristic type:CBCharacteristicWriteWithResponse];}/** 写入数据回调 */- (void)peripheral:(CBPeripheral *)peripheral didWriteValueForCharacteristic:(nonnull CBCharacteristic *)characteristic error:(nullable NSError *)error {    NSLog(@"写入成功");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5>  14、中心设备如何主动从外设读取数据呢。</h5> <pre class="line-numbers language-Objective-C"><code class="language-Objective-C">/** 读取数据 */- (IBAction)didClickGet:(id)sender {    [self.peripheral readValueForCharacteristic:self.characteristic];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>中心设备的开发是需要配合外设来进行的，一般会有硬件工程师或嵌入式工程师给出通信协议，根据协议来对项目的各种需求进行操作。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frontend </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
